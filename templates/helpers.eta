import P from "parse";

type Parse = typeof P;

/* === HELPERS === */
export async function processActionTriggers<C extends BaseServiceConfig>(
  registry: TriggerHandlerRegistry<C>,
  triggerType: string,
  request: TriggerHandlerRequest,
  Parse: Parse,
  config?: C
) {
  const { object } = request;
  const actionTriggerQuery = new Parse.Query<ActionTrigger>("ActionTrigger")
    .equalTo("active", true)
    .equalTo("objectClass", object.className)
    .equalTo("trigger", triggerType);
  const triggers = await actionTriggerQuery.findAll();

  for (const trigger of triggers) {
    const conditionMessage = await testTriggerCondition(trigger, object);

    if (conditionMessage != null) {
      // console.warn('[ACTION TRIGGER]', conditionMessage);
      continue;
    }

    const handlerName = trigger.get("handler");
    const handler = registry[handlerName];
    if (handler == null) continue;

    await handler(request, trigger, Parse, config);
  }
}

export async function testTriggerCondition<T extends Parse.Object = Parse.Object>(
  trigger: ActionTrigger,
  obj: T
): Promise<string | undefined> {
  const condition = trigger.get("condition") as ActionTriggerCondition | undefined;
  const property = trigger.get("property");
  const value = trigger.get("value");
  if (condition == null || property == null) return;

  const propertyValue = obj.get(property);
  const n1 = Number(propertyValue);
  const n2 = Number(value);
  const q = new Parse.Query(obj.className).equalTo(property, propertyValue);

  switch (condition) {
    case ActionTriggerCondition.Exists:
      return value != null ? undefined : `Property '${property}' does not exist`;
    case ActionTriggerCondition.DoesNotExist:
      return value == null ? undefined : `Property '${property}' exists (and should not)`;
    case ActionTriggerCondition.Contains:
      return !!propertyValue?.includes(value)
        ? undefined
        : `Property '${property}' does not contain value '${value}'`;
    case ActionTriggerCondition.Equals:
      return value === propertyValue ? undefined : `Property '${property}' does not equal value '${value}`;
    case ActionTriggerCondition.StartsWith:
      return propertyValue?.indexOf(value) === 0
        ? undefined
        : `Property '${property}' does not start with value '${value}'`;
    case ActionTriggerCondition.EndsWith:
      const endsWith =
        propertyValue && value ? propertyValue.indexOf(value) === propertyValue.length - value.length : false;
      return endsWith ? undefined : `Property '${property}' does not end with value '${value}'`;
    case ActionTriggerCondition.LessThan:
      const isLessThan = !isNaN(n1) && !isNaN(n2) ? n1 < n2 : false;
      return isLessThan ? undefined : `Property '${property}' `;
    case ActionTriggerCondition.LessThanOrEqualTo:
      const isLessThanOrEqualTo = !isNaN(n1) && !isNaN(n2) ? n1 <= n2 : false;
      return isLessThanOrEqualTo
        ? undefined
        : `Property '${property}' is not less than or equal to value '${value}'`;
    case ActionTriggerCondition.GreaterThan:
      const isGreaterThan = !isNaN(n1) && !isNaN(n2) ? n1 > n2 : false;
      return isGreaterThan ? undefined : `Property '${property}' is not greater than value '${value}'`;
    case ActionTriggerCondition.GreaterThanOrEqualTo:
      const isGreaterThanOrEqualTo = !isNaN(n1) && !isNaN(n2) ? n1 >= n2 : false;
      return isGreaterThanOrEqualTo
        ? undefined
        : `Property '${property}' is not greater than or equal to value '${value}'`;
    case ActionTriggerCondition.Unique:
      const res1 = await q.findAll({ useMasterKey: true });
      return res1.length === 0 ? undefined : `Property '${property}' is not unique, with value '${value}'`;
    case ActionTriggerCondition.NotUnique:
      const res2 = await q.findAll({ useMasterKey: true });
      return res2.length > 0
        ? undefined
        : `Property '${property}' is unique (and should not be), with value '${value}'`;
  }
}

export async function validateTriggerPayload(
  schema: TriggerPayloadSchema,
  payload: TriggerPayload
): Promise<TriggerValidationResult> {
  const errors: TriggerValidationResult = {};
  for (const schemaKey in schema) {
    const fieldSchema = schema[schemaKey];
    const val = payload[schemaKey];
    if (fieldSchema.required && (val == null || val == "")) {
      errors[schemaKey] = "This field is required";
    } else {
      switch (fieldSchema.type) {
        case "Relation":
        case "Pointer":
          const q = new Parse.Query(fieldSchema.targetClass!);
          const r = await q.get(val);
          if (r == null) {
            errors[schemaKey] = "This field is required";
          }
          break;
        case "String":
          if (typeof val !== "string") {
            errors[schemaKey] = "Please enter a string";
          }
          break;
        case "Number":
          if (isNaN(Number(val))) {
            errors[schemaKey] = "Please enter a number";
          }
          break;
        case "Date":
          if (isNaN(+new Date(val))) {
            errors[schemaKey] = "Please enter a valid date";
          }
          break;
      }
    }
  }
  return errors;
}

/* === GENERAL TYPES === */
export interface ParseObjectReference {
  id: string;
  className: string;
}

type ACLSchema = {
  [key: string]: {
    read?: boolean;
    write?: boolean;
  };
};

export type BaseServiceConfig = {
  aclSchema?: ACLSchema;
  [key: string]: any;
};

export type ServiceInitializer<T extends BaseServiceConfig = BaseServiceConfig> = (
  Parse: Parse,
  config?: T
) => any;

/* === TRIGGER TYPES === */
export interface ActionTriggerAttributes {
  id: string;
  objectClass: string;
  objectId: string;
  createdAt: Date;
  updatedAt: Date;
  name?: string;
  type?: string;
  condition: string;
  property?: string;
  value?: string;
  active?: boolean;
  trigger: string;
  handler: string;
  payload: object;
}

export type ActionTrigger = Parse.Object<ActionTriggerAttributes>;

export enum ActionTriggerCondition {
  Exists = "exists",
  DoesNotExist = "does not exist",
  Equals = "equals",
  Contains = "contains",
  StartsWith = "startsWith",
  EndsWith = "endsWith",
  LessThan = "lessThan",
  LessThanOrEqualTo = "lessThanOrEqualTo",
  GreaterThan = "greaterThan",
  GreaterThanOrEqualTo = "greaterThanOrEqualTo",
  Unique = "unique",
  NotUnique = "not unique",
}

export type TriggerCloudRequest = {
  triggerId: string;
  object: ParseObjectReference;
};

export type TriggerCloudRequestHandler = (params: TriggerCloudRequest) => any;

type TriggerPayloadOption = {
  label: string;
  value: string;
};

type TriggerPayloadParams = {
  type: string;
  targetClass?: string;
  required?: boolean;
  defaultValue?: any;
  options?: TriggerPayloadOption[];
};

export type TriggerPayloadSchema = { [key: string]: TriggerPayloadParams };
export type TriggerPayload = {
  [prop in keyof TriggerPayloadSchema]?: any;
};

type TriggerHandlerRequest =
  | Parse.Cloud.BeforeSaveRequest
  | Parse.Cloud.AfterSaveRequest
  | Parse.Cloud.BeforeDeleteRequest
  | Parse.Cloud.AfterDeleteRequest;

export type TriggerHandler<C extends BaseServiceConfig> = (
  request: TriggerHandlerRequest,
  trigger: ActionTrigger,
  Parse: Parse,
  config?: C
) => any;

export type TriggerHandlerRegistry<C extends BaseServiceConfig> = {
  [key: string]: TriggerHandler<C>;
};

type TriggerValidationResult = { [key: string]: string };

/* === HOOK TYPES === */
export type BeforeSaveHandler<T extends Parse.Object, C extends BaseServiceConfig> = (
  request: Parse.Cloud.BeforeSaveRequest<T>,
  Parse: Parse,
  config?: C
) => Promise<any>;

export type BeforeCreateHandler<T extends Parse.Object, C extends BaseServiceConfig> = BeforeSaveHandler<T, C>;
export type BeforeUpdateHandler<T extends Parse.Object, C extends BaseServiceConfig> = BeforeSaveHandler<T, C>;

export type AfterSaveHandler<T extends Parse.Object, C extends BaseServiceConfig> = (
  request: Parse.Cloud.AfterSaveRequest<T>,
  Parse: Parse,
  config?: C
) => Promise<any>;

export type AfterCreateHandler<T extends Parse.Object, C extends BaseServiceConfig> = AfterSaveHandler<T, C>;
export type AfterUpdateHandler<T extends Parse.Object, C extends BaseServiceConfig> = AfterSaveHandler<T, C>;

export type BeforeDeleteHandler<T extends Parse.Object, C extends BaseServiceConfig> = (
  request: Parse.Cloud.BeforeDeleteRequest<T>,
  Parse: Parse,
  config?: C
) => Promise<any>;

export type AfterDeleteHandler<T extends Parse.Object, C extends BaseServiceConfig> = (
  request: Parse.Cloud.AfterDeleteRequest<T>,
  Parse: Parse,
  config?: C
) => Promise<any>;
